# CAS

> 乐观锁 and 悲观锁

乐观锁，总是认为是线程安全的，不怕别的线程修改变量，如果修改了我就再重新尝试。

悲观锁：总是认为线程不安全，不管什么情况都进行加锁，要是获取锁失败，就阻塞。

> CAS 的定义

一个线程失败或挂起并不会导致其他线程也失败或挂起，那么这种算法就被称为非阻塞算法。而 CAS 就是一种非阻塞算法实现，也是一种乐观锁技术，它能在不使用锁的情况下实现多线程安全，所以 CAS 也是一种无锁算法。

CAS(Compare And Swap)比较并交换，是一种实现并发算法时常用到的技术，Java 并发包中的很多类都使用了 CAS 技术。

> CAS 的思想

CAS 具体包括三个参数：当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false。CAS 有效地说明了“ 我认为位置 V 应该包含值 A，如果真的包含 A 值，则将 B 放到这个位置，否则，不要更改该位置，只告诉我这个位置现在的值(A)即可。 ”整个比较并交换的操作是原子操作。

> 实现过程

假如现在有两个线程 t1,t2,，他们各自的运行环境中都有共享变量的副本 V1、V2，预期值 E1、E2，预期主存中的值还没有被改变，假设现在在并发环境，并且 t1 先拿到了执行权限，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试，然后 t1 比较预期值 E1 和主存中的 V，发现 E1=V，说明预期值是正确的，执行 N1=V1+1，并将 N1 的值传入主存。这时候贮存中的 V=21，然后 t2 又紧接着拿到了执行权，比较 E2 和主存 V 的值，由于 V 已经被 t1 改为 21，所以 E2！=V，t2 线程将主存中已经改变的值更新到自己的副本中，再发起重试；直到预期值等于主存中的值，说明没有别的线程对旧值进行修改，继续执行代码，退出；

> 实现原理

其实现方式是基于硬件平台的汇编指令，在 intel 的 CPU 中，使用的是 cmpxchg 指令，也就是说 CAS 是靠硬件实现的，从而在硬件层面提升效率。

> 优点

这个算法相对 synchronized 是比较“乐观的”，它不会像 synchronized 一样，当一个线程访问共享数据的时候，别的线程都在阻塞。synchronized 不管是否有线程冲突都会进行加锁。由于 CAS 是非阻塞的，它死锁问题天生免疫，并且线程间的相互影响也非常小，更重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，所以它要比锁的方式拥有更优越的性能。

> 缺点

- 循环时间太长；(如果 CAS 长时间尝试但是一直不成功，可能会给 CPU 带来很大的开销。)
- 只能保证一个共享变量原子操作；
- 会出现 ABA 问题；

> Tip

CAS（比较并交换）是 CPU 指令级的操作，只有一步原子操作，所以非常快。而且 CAS 避免了请求操作系统来裁定锁的问题，不用麻烦操作系统，直接在 CPU 内部就搞定了

> ABA 问题：

ABA 问题是 CAS 中的一个漏洞。CAS 的定义，当且仅当内存值 V 等于就得预期值 A 时，CAS 才会通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作。那么如果先将预期值 A 给成 B，再改回 A，那 CAS 操作就会误认为 A 的值从来没有被改变过，这时其他线程的 CAS 操作仍然能够成功，但是很明显是个漏洞，因为预期值 A 的值变化过了。如何解决这个异常现象？java 并发包为了解决这个漏洞，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证 CAS 的正确性，即在变量前面添加版本号，每次变量更新的时候都把版本号+1，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
