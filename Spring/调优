
数据库的调优
	数据库调优方法
1.	优化sql和索引（用慢查询日志定位执行效率低的SQL；用explain分析SQL的执行计划；确定问题，采取相应的优化措施，建立索引）
2.	搭建缓存（缓存和数据库一致性，缓存击穿、缓存穿透）
3.	读写分离（搞主从复制，上读写分离）
a.	主从好处：数据库备份，实现数据库负载均衡，提交数据库可用性
b.	原理：主库有一个log dump线程，将binlog传给从库
从库有两个线程，一个I/O线程，一个SQL线程，I/O线程读取主库传过来的binlog内容并写入到relay log,SQL线程从relay log里面读取内容，写入从库的数据库。
c.	解决主从一致性：我不建议在数据库层面解决该问题。根据CAP定理，主从架构本来就是一种高可用架构，是无法满足一致性的
所以利用缓存来解决。数据库的写操作，先写数据库，再写cache，但是有效期很短，就比主从延时的时间稍微长一点。
读请求的时候，先读缓存，缓存不存在(这时主从同步已经完成)，再读数据库。
d.	垂直拆分
索引优化
1.	如果MySQL估计使用索引比全表扫描还慢，则不会使用索引。
2.	前导模糊查询不能命中索引。
3.	数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来。
4.	复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中符合索引。
5.	union、in、or都能够命中索引，建议使用in。
6.	用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。
7.	负向条件查询不能使用索引，可以优化为in查询。
8.	范围条件查询可以命中索引。范围条件有：<、<=、>、>=、between等。
9.	数据库执行计算不会命中索引。
10.	利用覆盖索引进行查询，避免回表。
11.	建立索引的列，不允许为null。

数据库事物：
	⑴ 原子性（Atomicity）
　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
⑵ 一致性（Consistency）
　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
⑶ 隔离性（Isolation）
　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。
⑷ 持久性（Durability）
　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。
以上介绍完事务的四大特性(简称ACID)，
① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
　　② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
　　③ Read committed (读已提交)：可避免脏读的发生。
　　④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。
自动注入：
	@SpringBootApplication等同于下面三个注解：
•	@SpringBootConfiguration
•	@EnableAutoConfiguration
•	@ComponentScan
其中@EnableAutoConfiguration是关键(启用自动配置)，内部实际上就去加载META-INF/spring.factories文件的信息，然后筛选出以EnableAutoConfiguration为key的数据，加载到IOC容器中，实现自动配置功能！

ThreadLocal:
	ThreadLocal提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离～。

作用：ThreadLocal能够实现当前线程的操作都是用同一个Connection，保证了事务！
	原理：Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象
	目的：为了能够在当前线程中有属于自己的变量，并不是为了解决并发或者共享变量的问题


JVM调优




