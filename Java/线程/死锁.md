# 死锁

在 Java 中使用多线程，就会有可能导致死锁问题。死锁会让程序一直卡住，不再程序往下执行。我们只能通过中止并重启的方式来让程序重新执行

> 死锁的原因

- 当前线程拥有其他线程需要的资源
- 当前线程等待其他线程已拥有的资源
- 都不放弃自己拥有的资源

## 锁顺序死锁

    publicclassLeftRightDeadlock {
      privatefinalObjectleft=newObject();
      privatefinalObjectright=newObject();

      publicvoidleftRight() {
        // 得到left锁
        synchronized (left) {
          // 得到right锁
          synchronized (right) {
            doSomething();
          }
        }
      }

      publicvoidrightLeft() {
        // 得到right锁
        synchronized (right) {
          // 得到left锁
          synchronized (left) {
            doSomethingElse();
          }
        }
      }
    }

- 线程 A 调用 leftRight()方法，得到 left 锁
- 同时线程 B 调用 rightLeft()方法，得到 right 锁
- 线程 A 和线程 B 都继续执行，此时线程 A 需要 right 锁才能继续往下执行。此时线程 B 需要 left 锁才能继续往下执行。
- 但是：线程 A 的 left 锁并没有释放，线程 B 的 right 锁也没有释放。
- 所以他们都只能等待，而这种等待是无期限的-->永久等待-->死锁

## 动态锁顺序死锁

> 避免死锁的方法

- 固定加锁的顺序(针对锁顺序死锁)
- 开放调用(针对对象之间协作造成的死锁)
- 使用定时锁-->tryLock()如果等待获取锁时间超时，则抛出异常而不是一直等待
